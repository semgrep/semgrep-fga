(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_fga"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "imm_tok_colonstar", None;
  "imm_tok_prec_p1_hash", None;
  "float_literal", None;
  "operator",
  Some (
    Alt [|
      Token (Literal "or");
      Token (Literal "and");
      Token (Literal "but not");
    |];
  );
  "comment", None;
  "null_literal", None;
  "string_literal", None;
  "file", None;
  "identifier", None;
  "int_literal", None;
  "type_identifier",
  Some (
    Alt [|
      Token (Literal "string");
      Token (Literal "int");
      Token (Literal "map");
      Token (Literal "uint");
      Token (Literal "list");
      Token (Literal "timestamp");
      Token (Literal "bool");
      Token (Literal "duration");
      Token (Literal "double");
      Token (Literal "ipaddress");
    |];
  );
  "semgrep_metavariable", None;
  "semgrep_ellipsis", None;
  "version", None;
  "uint_literal", None;
  "boolean_literal",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "contents",
  Some (
    Seq [
      Token (Literal "contents:");
      Repeat (
        Seq [
          Token (Literal "-");
          Token (Name "file");
        ];
      );
    ];
  );
  "indirect_relation",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "from");
      Token (Name "identifier");
    ];
  );
  "module",
  Some (
    Seq [
      Token (Literal "module");
      Token (Name "identifier");
    ];
  );
  "selector_expression",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "all",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "imm_tok_colonstar");
    ];
  );
  "conditional",
  Some (
    Seq [
      Token (Literal "with");
      Token (Name "identifier");
    ];
  );
  "relation_ref",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "imm_tok_prec_p1_hash");
      Token (Name "identifier");
    ];
  );
  "param",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "semgrep_metavariable");
      |];
      Token (Literal ":");
      Alt [|
        Token (Name "type_identifier");
        Token (Name "semgrep_metavariable");
      |];
    ];
  );
  "schema",
  Some (
    Seq [
      Token (Literal "schema");
      Token (Name "version");
    ];
  );
  "quoted_version",
  Some (
    Seq [
      Token (Literal "'");
      Token (Name "version");
      Token (Literal "'");
    ];
  );
  "number_literal",
  Some (
    Alt [|
      Token (Name "float_literal");
      Token (Name "int_literal");
      Token (Name "uint_literal");
    |];
  );
  "direct_relationship",
  Some (
    Seq [
      Token (Literal "[");
      Alt [|
        Seq [
          Alt [|
            Token (Name "identifier");
            Token (Name "relation_ref");
            Token (Name "all");
            Token (Name "semgrep_metavariable");
          |];
          Opt (
            Token (Name "conditional");
          );
          Opt (
            Repeat (
              Seq [
                Token (Literal ",");
                Alt [|
                  Token (Name "identifier");
                  Token (Name "relation_ref");
                  Token (Name "all");
                  Token (Name "semgrep_metavariable");
                |];
                Opt (
                  Token (Name "conditional");
                );
              ];
            );
          );
        ];
        Token (Name "semgrep_ellipsis");
      |];
      Token (Literal "]");
    ];
  );
  "model",
  Some (
    Seq [
      Token (Literal "model");
      Token (Literal "\n");
      Token (Name "schema");
    ];
  );
  "quoted_schema",
  Some (
    Seq [
      Token (Literal "schema:");
      Token (Name "quoted_version");
    ];
  );
  "argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "expression");
          Opt (
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expression");
              ];
            );
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "*");
          Token (Literal "/");
          Token (Literal "%");
          Token (Literal "<<");
          Token (Literal ">>");
          Token (Literal "&");
          Token (Literal "&^");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "+");
          Token (Literal "-");
          Token (Literal "|");
          Token (Literal "^");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "==");
          Token (Literal "!=");
          Token (Literal "<");
          Token (Literal "<=");
          Token (Literal ">");
          Token (Literal ">=");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
    |];
  );
  "call_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "selector_expression");
        Token (Name "identifier");
      |];
      Token (Name "argument_list");
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "number_literal");
      Token (Name "boolean_literal");
      Token (Name "string_literal");
      Token (Name "null_literal");
      Token (Name "binary_expression");
      Token (Name "selector_expression");
      Token (Name "call_expression");
      Token (Name "identifier");
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_metavariable");
    |];
  );
  "relation_def",
  Some (
    Alt [|
      Token (Name "direct_relationship");
      Seq [
        Opt (
          Seq [
            Token (Name "direct_relationship");
            Token (Name "operator");
          ];
        );
        Alt [|
          Token (Name "identifier");
          Token (Name "indirect_relation");
        |];
        Opt (
          Repeat (
            Seq [
              Token (Name "operator");
              Alt [|
                Token (Name "identifier");
                Token (Name "indirect_relation");
              |];
            ];
          );
        );
      ];
    |];
  );
  "project_file",
  Some (
    Seq [
      Token (Name "quoted_schema");
      Token (Name "contents");
    ];
  );
  "condition_body",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "expression");
      Token (Literal "}");
    ];
  );
  "definition",
  Some (
    Seq [
      Token (Literal "define");
      Alt [|
        Token (Name "identifier");
        Token (Name "semgrep_metavariable");
      |];
      Token (Literal ":");
      Token (Name "relation_def");
    ];
  );
  "condition_declaration",
  Some (
    Seq [
      Token (Literal "condition");
      Token (Name "identifier");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "param");
          Opt (
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "param");
              ];
            );
          );
        ];
      );
      Token (Literal ")");
      Token (Name "condition_body");
    ];
  );
  "relations",
  Some (
    Seq [
      Token (Literal "relations");
      Repeat (
        Alt [|
          Token (Name "definition");
          Token (Name "semgrep_ellipsis");
        |];
      );
    ];
  );
  "type_declaration",
  Some (
    Seq [
      Opt (
        Token (Literal "extend");
      );
      Token (Literal "type");
      Alt [|
        Token (Name "identifier");
        Token (Name "semgrep_metavariable");
      |];
      Token (Literal "\n");
      Opt (
        Token (Name "relations");
      );
    ];
  );
  "module_file",
  Some (
    Seq [
      Alt [|
        Token (Name "model");
        Token (Name "module");
      |];
      Repeat (
        Alt [|
          Token (Name "type_declaration");
          Token (Name "condition_declaration");
          Token (Name "semgrep_ellipsis");
        |];
      );
    ];
  );
  "source_file",
  Some (
    Alt [|
      Token (Name "project_file");
      Token (Name "module_file");
    |];
  );
]


let trans_imm_tok_colonstar ((kind, body) : mt) : CST.imm_tok_colonstar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_imm_tok_prec_p1_hash ((kind, body) : mt) : CST.imm_tok_prec_p1_hash =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_float_literal ((kind, body) : mt) : CST.float_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_operator ((kind, body) : mt) : CST.operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Or (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `And (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `ButS (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null_literal ((kind, body) : mt) : CST.null_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_file ((kind, body) : mt) : CST.file =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_int_literal ((kind, body) : mt) : CST.int_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_type_identifier ((kind, body) : mt) : CST.type_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Int (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Map (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Uint (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `List (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Time (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Bool (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Dura (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Double (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Ipad (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_metavariable ((kind, body) : mt) : CST.semgrep_metavariable =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_version ((kind, body) : mt) : CST.version =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_uint_literal ((kind, body) : mt) : CST.uint_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_boolean_literal ((kind, body) : mt) : CST.boolean_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_contents ((kind, body) : mt) : CST.contents =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_file (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_indirect_relation ((kind, body) : mt) : CST.indirect_relation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_ ((kind, body) : mt) : CST.module_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_selector_expression ((kind, body) : mt) : CST.selector_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_all ((kind, body) : mt) : CST.all =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_imm_tok_colonstar (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_conditional ((kind, body) : mt) : CST.conditional =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_relation_ref ((kind, body) : mt) : CST.relation_ref =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_imm_tok_prec_p1_hash (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_param ((kind, body) : mt) : CST.param =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Semg_meta (
                  trans_semgrep_metavariable (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Type_id (
                  trans_type_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Semg_meta (
                  trans_semgrep_metavariable (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_schema ((kind, body) : mt) : CST.schema =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_version (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_quoted_version ((kind, body) : mt) : CST.quoted_version =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_version (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_number_literal ((kind, body) : mt) : CST.number_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Float_lit (
            trans_float_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Int_lit (
            trans_int_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Uint_lit (
            trans_uint_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_direct_relationship ((kind, body) : mt) : CST.direct_relationship =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Choice_id_opt_cond_opt_rep_COMMA_choice_id_opt_cond (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Id (
                              trans_identifier (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Rela_ref (
                              trans_relation_ref (Run.matcher_token v)
                            )
                        | Alt (2, v) ->
                            `All (
                              trans_all (Run.matcher_token v)
                            )
                        | Alt (3, v) ->
                            `Semg_meta (
                              trans_semgrep_metavariable (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.opt
                          (fun v -> trans_conditional (Run.matcher_token v))
                          v1
                        ,
                        Run.opt
                          (fun v ->
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1; v2] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      (match v1 with
                                      | Alt (0, v) ->
                                          `Id (
                                            trans_identifier (Run.matcher_token v)
                                          )
                                      | Alt (1, v) ->
                                          `Rela_ref (
                                            trans_relation_ref (Run.matcher_token v)
                                          )
                                      | Alt (2, v) ->
                                          `All (
                                            trans_all (Run.matcher_token v)
                                          )
                                      | Alt (3, v) ->
                                          `Semg_meta (
                                            trans_semgrep_metavariable (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                      ,
                                      Run.opt
                                        (fun v -> trans_conditional (Run.matcher_token v))
                                        v2
                                    )
                                | _ -> assert false
                                )
                              )
                              v
                          )
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Semg_ellips (
                  trans_semgrep_ellipsis (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_model ((kind, body) : mt) : CST.model =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_schema (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_quoted_schema ((kind, body) : mt) : CST.quoted_schema =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_quoted_version (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          Run.repeat
                            (fun v ->
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    trans_expression (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                            v
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_choice_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `SLASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `PERC (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `LTLT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (4, v) ->
                      `GTGT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (5, v) ->
                      `AMP (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (6, v) ->
                      `AMPHAT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_choice_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `BAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `HAT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_choice_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `EQEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `BANGEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `LT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `LTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (4, v) ->
                      `GT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (5, v) ->
                      `GTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expression ((kind, body) : mt) : CST.call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Sele_exp (
                  trans_selector_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Num_lit (
            trans_number_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bool_lit (
            trans_boolean_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Sele_exp (
            trans_selector_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Call_exp (
            trans_call_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_relation_def ((kind, body) : mt) : CST.relation_def =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Direct_rela (
            trans_direct_relationship (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Opt_direct_rela_op_choice_id_opt_rep_op_choice_id (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_direct_relationship (Run.matcher_token v0),
                            trans_operator (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Indi_rela (
                        trans_indirect_relation (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v ->
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                trans_operator (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Id (
                                      trans_identifier (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Indi_rela (
                                      trans_indirect_relation (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v
                    )
                    v2
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_project_file ((kind, body) : mt) : CST.project_file =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_quoted_schema (Run.matcher_token v0),
            trans_contents (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_condition_body ((kind, body) : mt) : CST.condition_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_definition ((kind, body) : mt) : CST.definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Semg_meta (
                  trans_semgrep_metavariable (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_relation_def (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_condition_declaration ((kind, body) : mt) : CST.condition_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_param (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          Run.repeat
                            (fun v ->
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    Run.trans_token (Run.matcher_token v0),
                                    trans_param (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                            v
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_condition_body (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_relations ((kind, body) : mt) : CST.relations =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Defi (
                      trans_definition (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Semg_ellips (
                      trans_semgrep_ellipsis (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_declaration ((kind, body) : mt) : CST.type_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Semg_meta (
                  trans_semgrep_metavariable (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_relations (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_file ((kind, body) : mt) : CST.module_file =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Model (
                  trans_model (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Module (
                  trans_module_ (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Type_decl (
                      trans_type_declaration (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Cond_decl (
                      trans_condition_declaration (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Semg_ellips (
                      trans_semgrep_ellipsis (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Proj_file (
            trans_project_file (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Module_file (
            trans_module_file (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "comment" ->
      (match translate_tree src node trans_comment with
      | None -> None
      | Some x -> Some (`Comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_source_file

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

