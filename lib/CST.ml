(* Generated by ocaml-tree-sitter. *)
(*
   fga grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type imm_tok_prec_p1_hash = Token.t (* "#" *)

type file = Token.t (* pattern .+\..+ *)

type float_literal = Token.t

type identifier = Token.t (* pattern [a-zA-Z_-]+ *)

type operator = [
    `Or of Token.t (* "or" *)
  | `And of Token.t (* "and" *)
  | `ButS of Token.t (* "but not" *)
]

type imm_tok_colonstar = Token.t (* ":*" *)

type version = Token.t (* pattern [0-9]+\.[0-9]+ *)

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type semgrep_metavariable = Token.t (* pattern \$[A-Z_][A-Z_0-9]* *)

type type_identifier = [
    `Str of Token.t (* "string" *)
  | `Int of Token.t (* "int" *)
  | `Map of Token.t (* "map" *)
  | `Uint of Token.t (* "uint" *)
  | `List of Token.t (* "list" *)
  | `Time of Token.t (* "timestamp" *)
  | `Bool of Token.t (* "bool" *)
  | `Dura of Token.t (* "duration" *)
  | `Double of Token.t (* "double" *)
  | `Ipad of Token.t (* "ipaddress" *)
]

type uint_literal = Token.t

type string_literal = Token.t

type comparative_operator = [
    `EQEQ of Token.t (* "==" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `LT of Token.t (* "<" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GT of Token.t (* ">" *)
  | `GTEQ of Token.t (* ">=" *)
]

type int_literal = Token.t

type contents = (
    Token.t (* "contents:" *)
  * (Token.t (* "-" *) * file (*tok*)) list (* zero or more *)
)

type module_ = (Token.t (* "module" *) * identifier (*tok*))

type conditional = (Token.t (* "with" *) * identifier (*tok*))

type selector_expression = (
    identifier (*tok*) * Token.t (* "." *) * identifier (*tok*)
)

type quoted_version = (
    Token.t (* "'" *) * version (*tok*) * Token.t (* "'" *)
)

type schema = (Token.t (* "schema" *) * version (*tok*))

type anon_choice_id_684e964 = [
    `Id of identifier (*tok*)
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type number_literal = [
    `Float_lit of float_literal (*tok*)
  | `Int_lit of int_literal (*tok*)
  | `Uint_lit of uint_literal (*tok*)
]

type anon_choice_id_096b091 = [
    `Id of identifier (*tok*)
  | `Indi_rela of (
        identifier (*tok*) * Token.t (* "from" *) * identifier (*tok*)
    )
]

type anon_choice_id_6cee6b4 = [
    `Id of identifier (*tok*)
  | `Rela_ref of (
        identifier (*tok*) * imm_tok_prec_p1_hash (*tok*)
      * identifier (*tok*)
    )
  | `All of (identifier (*tok*) * imm_tok_colonstar (*tok*))
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type quoted_schema = (Token.t (* "schema:" *) * quoted_version)

type model = (Token.t (* "model" *) * Token.t (* "\n" *) * schema)

type param = (
    anon_choice_id_684e964
  * Token.t (* ":" *)
  * [
        `Type_id of type_identifier
      | `Semg_meta of semgrep_metavariable (*tok*)
    ]
)

type argument_list = (
    Token.t (* "(" *)
  * (
        expression
      * (Token.t (* "," *) * expression) list (* zero or more *) option
    )
      option
  * Token.t (* ")" *)
)

and binary_expression = [
    `Exp_choice_STAR_exp of (
        expression
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
          | `LTLT of Token.t (* "<<" *)
          | `GTGT of Token.t (* ">>" *)
          | `AMP of Token.t (* "&" *)
          | `AMPHAT of Token.t (* "&^" *)
        ]
      * expression
    )
  | `Exp_choice_PLUS_exp of (
        expression
      * [
            `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `BAR of Token.t (* "|" *)
          | `HAT of Token.t (* "^" *)
        ]
      * expression
    )
  | `Exp_choice_EQEQ_exp of (expression * comparative_operator * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
]

and expression = [
    `Num_lit of number_literal
  | `Bool_lit of boolean_literal
  | `Str_lit of string_literal (*tok*)
  | `Null_lit of Token.t (* "null" *)
  | `Bin_exp of binary_expression
  | `Sele_exp of selector_expression
  | `Call_exp of (
        [ `Sele_exp of selector_expression | `Id of identifier (*tok*) ]
      * argument_list
    )
  | `Id of identifier (*tok*)
  | `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type direct_relationship = (
    Token.t (* "[" *)
  * [
        `Choice_id_opt_cond_opt_rep_COMMA_choice_id_opt_cond of (
            anon_choice_id_6cee6b4
          * conditional option
          * (Token.t (* "," *) * anon_choice_id_6cee6b4 * conditional option)
              list (* zero or more *)
              option
        )
      | `Semg_ellips of Token.t (* "..." *)
    ]
  * Token.t (* "]" *)
)

type condition_body = (Token.t (* "{" *) * expression * Token.t (* "}" *))

type relation_def = [
    `Direct_rela of direct_relationship
  | `Opt_direct_rela_op_choice_id_opt_rep_op_choice_id of (
        (direct_relationship * operator) option
      * anon_choice_id_096b091
      * (operator * anon_choice_id_096b091) list (* zero or more *) option
    )
]

type condition_declaration = (
    Token.t (* "condition" *)
  * identifier (*tok*)
  * Token.t (* "(" *)
  * (param * (Token.t (* "," *) * param) list (* zero or more *) option)
      option
  * Token.t (* ")" *)
  * condition_body
)

type definition = (
    Token.t (* "define" *) * anon_choice_id_684e964 * Token.t (* ":" *)
  * relation_def
)

type relations = (
    Token.t (* "relations" *)
  * [ `Defi of definition | `Semg_ellips of Token.t (* "..." *) ]
      list (* zero or more *)
)

type type_declaration = (
    Token.t (* "extend" *) option
  * Token.t (* "type" *)
  * anon_choice_id_684e964
  * Token.t (* "\n" *)
  * relations option
)

type source_file = [
    `Proj_file of (quoted_schema * contents)
  | `Module_file of (
        [ `Model of model | `Module of module_ ]
      * [
            `Type_decl of type_declaration
          | `Cond_decl of condition_declaration
          | `Semg_ellips of Token.t (* "..." *)
        ]
          list (* zero or more *)
    )
]

type null_literal (* inlined *) = Token.t (* "null" *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type comment (* inlined *) = Token.t

type indirect_relation (* inlined *) = (
    identifier (*tok*) * Token.t (* "from" *) * identifier (*tok*)
)

type relation_ref (* inlined *) = (
    identifier (*tok*) * imm_tok_prec_p1_hash (*tok*) * identifier (*tok*)
)

type all (* inlined *) = (identifier (*tok*) * imm_tok_colonstar (*tok*))

type call_expression (* inlined *) = (
    [ `Sele_exp of selector_expression | `Id of identifier (*tok*) ]
  * argument_list
)

type project_file (* inlined *) = (quoted_schema * contents)

type unary_expression (* inlined *) = (
    [
        `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `BANG of Token.t (* "!" *)
    ]
  * expression
)

type module_file (* inlined *) = (
    [ `Model of model | `Module of module_ ]
  * [
        `Type_decl of type_declaration
      | `Cond_decl of condition_declaration
      | `Semg_ellips of Token.t (* "..." *)
    ]
      list (* zero or more *)
)

type extra = [ `Comment of Loc.t * comment ]

type extras = extra list
